# import shapely
import math
from dataclasses import dataclass


class LineMaker:
    @staticmethod
    def make_line_with_2_points(p1,p2):
        x1,y1 = p1
        x2,y2 = p2
        x= x1-x2
        y= y1-y2

        # y = mx + c 
        # y1 = x1 + c
        c = y1 - x1 
        m = y/x
        line = Line(m=m, c=c, p1=p1, p2=p2)
        return line
    
    @staticmethod
    def make_line_with_c_and_m(c,m):
        line = Line(m = m, c = c)
        return line
    
    @staticmethod
    def make_line_with_pg(p1,m):
        # y1 - y2 = m(x1-x2)
        # y = m(x1) - mx + y2 
        # y = -mx + (m(x1) + y2)
        c = (m*p1[0]) + p1[1]
        m = m * -1
        line = Line(m = m, c = c)
        return line
        
@dataclass
class Line:
    m: float
    c: float = 0
    p1: tuple = None
    p2: tuple = None
    traveled_to: bool = False

    def add_start_end_point(self,p1,p2):
        self.p1 = p1 
        self.p2 = p2

class CPP:
    def __init__(self,scan_width,external_polygon):
        self.scan_width = scan_width
        self.external_polygon_lon_lat = external_polygon
        self.graident = self._find_palth_graident(external_polygon)

        # can use holes later 
        self.boundary_poly = self._convert_poly_to_rel(external_polygon)

    def _convert_gps_to_rel(self,gps_point,poly_center): # -> point (x,y)
        lon, lat = gps_point
        lon0, lat0 = poly_center
        EARTH_RADIUS = 6371 * 1000

        x = math.radians((lon - lon0)) * (EARTH_RADIUS * math.cos(math.radians(lat0)))
        y = math.radians((lat - lat0)) * EARTH_RADIUS

        return (x, y)

    def _convert_rel_to_gps(self,rel_point,poly_center): # -> point (x,y)
        x, y = rel_point
        lon0, lat0 = poly_center
        EARTH_RADIUS = 6371 * 1000 

        # x = (lon - lon0) * (EARTH_RADIUS * math.cos(math.radians(lat0))) * (math.pi / 180)
        # y = (lat - lat0) * EARTH_RADIUS * (math.pi / 180)

        lon = x / (EARTH_RADIUS * math.cos(math.radians(lat0)))
        lat = y / EARTH_RADIUS
        lon = math.degrees(lon) + lon0
        lat = math.degrees(lat) + lat0

        return (lon,lat)

    def _center_of_poly(self,poly): # [(lon lat), ] -> (ave_lon,ave_lat)
        average_lon = 0
        average_lat = 0 
        sum_lon = 0
        sum_lat = 0 

        count = len(poly)

        for i in poly:
            sum_lon += i[0]
            sum_lat += i[1]

        ave_tuple = (sum_lon/count,sum_lat/count) 

        return ave_tuple
    
    def _convert_poly_to_rel(self,poly):
        center = self._center_of_poly(poly)
        rel_poly = []
        for i in poly:
            point = self._convert_gps_to_rel(i,center)
            rel_poly.append(point)


        return rel_poly
        # return shapely.polygons(rel_poly)

    def _convert_rel_poly_to_gps(self,poly):
        center = self._center_of_poly(poly)
        rel_poly = []
        for i in poly:
            point = self._convert_rel_to_gps(i,center)
            rel_poly.append(point)


        return rel_poly

    def _dist_between_points(self,p1,p2): # (x,y) -> dist in m
        x1,y1 = p1
        x2,y2 = p2
        x= x1-x2
        y= y1-y2

        dist = ((x)** 2 + (y)** 2)** 0.5
        return dist
    
    def _find_palth_graident(self,poly):
        max_dist = 0 
        points = [(0,0),(0,0)]

        for i in range(len(poly)-1):
            point1 = poly[i]
            point2 = poly[i+1]
            if max_dist <= (new_dist := self._dist_between_points(point1,point2)):
                max_dist = new_dist
                points = [point1,point2]
        
        # y = mx + c 
        # pg fomual is y1 - y2 = m(x1- x2)
        # m = (y1 - y2) / (x1 - x2)

        x1,y1 = point1
        x2,y2 = point2
        x= x1-x2
        y= y1-y2

        m = y/x

        return m 

    def _find_intersection_points(self,poly, line: Line): 
        # y = mx + c
        # m1x + c1 = m2x + c2 
        # m1x - m2x + c1 = c2 
        # x(m1 - m2) = (c2 - c1)
        # x = (c2 - c1) / (m1 - m2)
        # X = x 
        # y = m1(X) + c1
        # Y = m1((c2 - c1) / (m1 - m2)) + c1
        
        # line is 1
        # poly is 2
        intersection = []
        for i in range(len(poly)-1):
            i = LineMaker.make_line_with_2_points(poly[i],poly[i+1])
            if i.m == line.m:
                continue
            x = (i.c - line.c) / (i.m - line.m) 
            y = (line.m * x) + line.c
            
            x_min = min(i.p1[0],i.p2[0])
            x_max = max(i.p1[0],i.p2[0])

            y_min = min(i.p1[1],i.p2[1])
            y_max = max(i.p1[1],i.p2[1])
            
            if x >= x_min and x <= x_max and y >= y_min and y <= y_max:
                point = (x,y)
                intersection.append(point)

        if len(intersection) % 2 != 0:
            raise ValueError("ther should be a even number of intersections")
        intersection = sorted(intersection, key =lambda i : i[0])
        
        if intersection == []:
            return None
        return intersection

    def _split_up_lines_by_intersections(self,poly,line: Line):
        intersection = self._find_intersection_points(poly,line)

        lines = []
        for i in range(len(intersection)):
            if i % 2 == 1:
                continue
            line = LineMaker(intersection[i],intersection[i+1])
            lines.append(line) 

        return lines

    def _make_lines(self,poly,scan_width=None):
        if not scan_width:
            scan_width = self.scan_width

        lines = []
        center = self._center_of_poly(poly)
        m = self.graident 

        center = self._center_of_poly(poly)
        m = self.graident 

        center_line = LineMaker.make_line_with_pg(p1=center,m=m)
        lines.append(center_line)

        current_line = center_line
        while True:
            c = current_line.c + scan_width
            current_line = LineMaker.make_line_with_c_and_m(c=c,m=m)
            if self._find_intersection_points(poly,current_line) != None:
                lines.append(current_line)
            else: break

        lines = lines[::-1] # to make the lines go all in the same direction

        current_line = center_line
        while True:
            c = current_line.c - scan_width
            current_line = LineMaker.make_line_with_c_and_m(c=c,m=m)
            if self._find_intersection_points(poly,current_line) != None:
                lines.append(current_line)
            else: break

        return lines

    def _split_array_of_lines(self,poly,lines_array:list[Line]):
        new_lines_array = []
        for i in lines_array:
            i = self._split_up_lines_by_intersections(poly,i)

            if type(i) != list: i = [i]

            new_lines_array.extend(i)

        return new_lines_array


    def genarate_scan_palth(self,poly,scan_width):
        lon_lat_poly = poly
        poly = self._convert_poly_to_rel(poly)
        lines = self._make_lines(poly,scan_width)
        return poly,lines

if __name__ == "__main__":
    import matplotlib.pyplot as plt

    def plot_scan_paths(polygon, lines, extend_factor=2.0, polygon_color='k', line_color='r'):
        """
        Plot polygon and scan lines.

        Parameters:
        - polygon: list of (x,y) tuples defining polygon vertices
        - lines: list of Line objects with .m and .c attributes
        """
        print(f"Plotting {len(lines)} lines")

        # Plot the polygon
        poly_x = [p[0] for p in polygon] + [polygon[0][0]]
        poly_y = [p[1] for p in polygon] + [polygon[0][1]]
        plt.plot(poly_x, poly_y, f'{polygon_color}-', linewidth=2, label='Polygon')

        # Get polygon bounds to extend lines
        x_min = min(p[0] for p in polygon)
        x_max = max(p[0] for p in polygon)
        y_min = min(p[1] for p in polygon)
        y_max = max(p[1] for p in polygon)

        # Extend bounds
        x_range = x_max - x_min
        y_range = y_max - y_min
        x_min -= x_range * 0.1
        x_max += x_range * 0.1
        y_min -= y_range * 0.1
        y_max += y_range * 0.1

        # For each line, find intersections with polygon edges
        for idx, line in enumerate(lines):
            m = line.m
            c = line.c

            if idx < 3:  # Debug first 3 lines
                print(f"\n  Analyzing line {idx}: y = {m:.6f}*x + {c:.2f}")

            # Find all intersection points
            intersections = []

            for i in range(len(polygon)):
                p1 = polygon[i]
                p2 = polygon[(i + 1) % len(polygon)]

                x1, y1 = p1
                x2, y2 = p2

                # Check if edge is vertical
                if abs(x2 - x1) < 1e-10:
                    # Vertical edge: x = x1
                    xi = x1
                    yi = m * xi + c
                    # Check if intersection is within the edge
                    if min(y1, y2) <= yi <= max(y1, y2):
                        intersections.append((xi, yi))
                        if idx < 3:
                            print(f"    Found intersection at ({xi:.2f}, {yi:.2f}) on vertical edge")
                else:
                    # Non-vertical edge
                    m_edge = (y2 - y1) / (x2 - x1)
                    c_edge = y1 - m_edge * x1

                    # Check if lines are parallel
                    if abs(m - m_edge) > 1e-10:
                        # Find intersection
                        xi = (c_edge - c) / (m - m_edge)
                        yi = m * xi + c

                        # Check if intersection is within the edge bounds
                        if min(x1, x2) <= xi <= max(x1, x2) and min(y1, y2) <= yi <= max(y1, y2):
                            intersections.append((xi, yi))
                            if idx < 3:
                                print(f"    Found intersection at ({xi:.2f}, {yi:.2f})")

            # Remove duplicate intersections
            unique_intersections = []
            for pt in intersections:
                is_duplicate = False
                for upt in unique_intersections:
                    if abs(pt[0] - upt[0]) < 1e-6 and abs(pt[1] - upt[1]) < 1e-6:
                        is_duplicate = True
                        break
                if not is_duplicate:
                    unique_intersections.append(pt)

            # Sort by x coordinate
            unique_intersections.sort(key=lambda p: (p[0], p[1]))

            # Plot line segments between pairs of intersections
            if len(unique_intersections) >= 2:
                for i in range(0, len(unique_intersections) - 1, 2):
                    pt1 = unique_intersections[i]
                    pt2 = unique_intersections[i + 1]
                    plt.plot([pt1[0], pt2[0]], [pt1[1], pt2[1]],
                            color=line_color, linewidth=1, alpha=0.7)
                print(f"Line {idx}: plotted {len(unique_intersections)//2} segment(s)")
            else:
                print(f"Line {idx}: only {len(unique_intersections)} intersections found")

        plt.gca().set_aspect('equal', adjustable='box')
        plt.xlabel('X (m)')
        plt.ylabel('Y (m)')
        plt.title('Polygon with Scan Lines')
        plt.grid(True, alpha=0.3)
        plt.legend()
        plt.show()


    test_data = {
    "timestamp": "20251216_180012",
    "boundary": [
        [
        -35.353793628499425,
        149.16532516479495
        ],
        [
        -35.35634869955396,
        149.1591024398804
        ],
        [
        -35.35865869421017,
        149.15627002716067
        ],
        [
        -35.360933624359085,
        149.1567420959473
        ],
        [
        -35.36317349295723,
        149.16139841079715
        ],
        [
        -35.364905848708105,
        149.1684150695801
        ],
        [
        -35.364975842098524,
        149.1697669029236
        ],
        [
        -35.362508538452815,
        149.17315721511844
        ],
        [
        -35.35780120390604,
        149.17667627334598
        ],
        [
        -35.353863631523176,
        149.17785644531253
        ],
        [
        -35.35284858173993,
        149.17564630508426
        ],
        [
        -35.35500117215463,
        149.17362928390506
        ],
        [
        -35.35937617909993,
        149.17384386062625
        ],
        [
        -35.361073617967,
        149.17201995849612
        ],
        [
        -35.36186107748863,
        149.16646242141726
        ],
        [
        -35.36137110357785,
        149.162814617157
        ],
        [
        -35.35946367682106,
        149.16238546371463
        ],
        [
        -35.358186783792384,
        149.1668594529933
        ],
        [
        -35.35890368976739,
        149.17000293731692
        ],
        [
        -35.356068695711336,
        149.17103290557864
        ],
        [
        -35.3524460584657,
        149.17017459869388
        ],
        [
        -35.35137848702254,
        149.1681790351868
        ],
        [
        -35.35192102509314,
        149.1659474372864
        ],
        [
        -35.35234105206425,
        149.16277170181277
        ],
        [
        -35.35363612147413,
        149.15766477584842
        ],
        [
        -35.35561368739635,
        149.15431737899783
        ],
        [
        -35.35664620257297,
        149.15345907211307
        ],
        [
        -35.35627869868433,
        149.15622711181643
        ],
        [
        -35.35424864706918,
        149.1586518287659
        ],
        [
        -35.35302359123341,
        149.1624712944031
        ],
        [
        -35.352533563695985,
        149.16566848754886
        ],
        [
        -35.353723625414986,
        149.16708469390872
        ],
        [
        -35.355298680138,
        149.16744947433475
        ],
        [
        -35.3544936560064,
        149.165153503418
        ]
    ],
    "obstacles": [],
    "scan_spacing": 25,
    "altitude": 20
    }

    obj = CPP(scan_width=0.0000001,external_polygon=test_data['boundary'])
    palth = obj.genarate_scan_palth(test_data['boundary'],scan_width=25)

    print(f"\nPolygon has {len(palth[0])} vertices")
    print(f"Generated {len(palth[1])} lines")
    print(f"\nFirst 3 polygon points:")
    for i, p in enumerate(palth[0][:3]):
        print(f"  Point {i}: ({p[0]:.2f}, {p[1]:.2f})")

    print(f"\nFirst 3 lines:")
    for i, line in enumerate(palth[1][:3]):
        print(f"  Line {i}: m={line.m:.6f}, c={line.c:.2f}")

    print(f"\nLast 3 lines:")
    for i, line in enumerate(palth[1][-3:]):
        print(f"  Line {len(palth[1])-3+i}: m={line.m:.6f}, c={line.c:.2f}")

    plot_scan_paths(palth[0],palth[1])